import psycopg2
from psycopg2.extras import RealDictCursor

# Import User from the project domain model
try:
    from Objet_Metier.User import User
except Exception:
    from src.Objet_Metier.User import User


class UserDAO:
    """DAO minimal pour User : create, read, update, delete, list.

    Cette classe attend une connexion psycopg2 existante ou une DSN.
    """

    def __init__(self, conn=None, dsn=None):
        """Create a connection to the database. Provide either a full dsn or connection parts."""
        if conn is not None:
            self.conn = conn
        else:
            if dsn is None:
                raise ValueError("Il faut fournir une connexion ou un dsn")
            self.conn = psycopg2.connect(dsn)
            self.conn.autocommit = False

    def create_user(self, user: User) -> User:
        """Insère un utilisateur et retourne l'objet User avec l'id attribué par la BDD."""
        sql = (
            "INSERT INTO users (username, nom, prenom, mail, password_hash, salt, "
            "sign_in_date, last_login, status, setting_param) "
            "VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s) RETURNING id, sign_in_date, last_login"
        )
        params = (
            user.username,
            user.nom,
            user.prenom,
            user.mail,
            user.password_hash,
            user.salt,
            user.sign_in_date,
            user.last_login,
            user.status,
            user.setting_param,
        )
        try:
            with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(sql, params)
                row = cur.fetchone()
                self.conn.commit()
                if not row:
                    return None
                return User(
                    int(row.get("id")),
                    user.username,
                    user.nom,
                    user.prenom,
                    user.mail,
                    user.password_hash,
                    user.salt,
                    row.get("sign_in_date"),
                    row.get("last_login"),
                    user.status,
                    user.setting_param,
                )
        except Exception:
            self.conn.rollback()
            raise

    def get_by_id(self, id: int):
        """Récupère un utilisateur par id."""
        sql = "SELECT * FROM users WHERE id = %s"
        with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute(sql, (id,))
            row = cur.fetchone()
            if not row:
                return None
            return self._row_to_user(row)

    def get_by_username(self, username: str):
        """Récupère un utilisateur par username."""
        sql = "SELECT * FROM users WHERE username = %s"
        with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute(sql, (username,))
            row = cur.fetchone()
            if not row:
                return None
            return self._row_to_user(row)

    def update_user(self, user: User) -> bool:
        """Met à jour un utilisateur existant. Retourne True si une ligne a été modifiée."""
        sql = (
            "UPDATE users SET username=%s, nom=%s, prenom=%s, mail=%s, password_hash=%s, "
            "salt=%s, sign_in_date=%s, last_login=%s, status=%s, setting_param=%s WHERE id=%s"
        )
        params = (
            user.username,
            user.nom,
            user.prenom,
            user.mail,
            user.password_hash,
            user.salt,
            user.sign_in_date,
            user.last_login,
            user.status,
            user.setting_param,
            user.id,
        )
        try:
            with self.conn.cursor() as cur:
                cur.execute(sql, params)
                updated = cur.rowcount
                self.conn.commit()
                return updated > 0
        except Exception:
            self.conn.rollback()
            raise

    def delete_user(self, id: int) -> bool:
        """Supprime un utilisateur par id. Retourne True si supprimé."""
        sql = "DELETE FROM users WHERE id = %s"
        try:
            with self.conn.cursor() as cur:
                cur.execute(sql, (id,))
                deleted = cur.rowcount
                self.conn.commit()
                return deleted > 0
        except Exception:
            self.conn.rollback()
            raise

    def list_users(self):
        """Retourne la liste de tous les utilisateurs."""
        sql = "SELECT * FROM users ORDER BY id"
        with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
            cur.execute(sql)
            rows = cur.fetchall()
            return [self._row_to_user(r) for r in rows]

    def _row_to_user(self, row: dict) -> User:
        """Convertit une ligne de la BDD (RealDictRow) en instance User."""
        return User(
            int(row.get("id")),
            row.get("username"),
            row.get("nom") or "",
            row.get("prenom") or "",
            row.get("mail"),
            row.get("password_hash"),
            row.get("salt"),
            row.get("sign_in_date"),
            row.get("last_login"),
            row.get("status") or "",
            row.get("setting_param") or "",
        )
